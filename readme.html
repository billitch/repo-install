<html>
  <head>
    <link rel="stylesheet" href="style.css" type="text/css"/>
    <title>Repo-install: An ASDF-install replacement geared towards collaboration</title>
  </head>
  <body>

    <h1>Repo-install: An ASDF-install replacement geared towards collaboration</h1>

    <p>Repo-install is a common lisp package manager that can be used to
      chase down and download dependencies between common lisp
      packages. Unlike other package managers (asdf-install, mudballs),
      repo-install maintains the connection between source code on your
      disk, and the upstream repository.</p>

    <p> In cases where the upstream package is stored using
      distributed version control (DVC), the local files are stored in
      the same DVC system as a clone.</p>

    <p> When the upstream package is not a DVC, repo-install will
      create a local DVC repository with the non-DVC distribution system
      (tarballs, cvs, or svn), as input to the local repository.</p>

    <p>There are two primary advantages to this: 
      <ul>
	<li>Changes you make to your local copy of the package remain
	  in place even when you update to a newer version of the
	  package.</li>
	<li>It is much easier to submit patches to the upstream
	  maintainer. For DVC, it is also much easier for the upstream
	  maintainer to integrate your patches.</li>
    </ul></p>

    <p>Both of these capabilities are particularly important when
      working on common lisp. Several very useful common lisp packages
      are maintained on a less than full time basis. You may need to
      maintain your local patches for weeks or forever if the upstream
      maintainer doesn't have the time to integrate them sooner.</p>

    <p>Unlike Perl, Python, and Ruby, common lisp does not have a
      reference implementation. Downstream users can submit valuable
      patches for different lisp environments, especially environments
      that are not easily available to a package maintainer.</p>

    <p>Finally, common-lisp users tend to be very technical. With such
      an experienced user base, downstream patches should turn out to be
      more valuable than not.</p>

    <h2>Why not clbuild?</h2>
    <p> <a href="http://common-lisp.net/project/clbuild">Clbuild</a>
      is another common lisp package manager that works with
      downstream repositories as opposed to tarballs. I decided not to
      use it because it was missing some functionality I needed
      (ri:all-repo-status, ri:all-repo-local-changes and TODOs below).
      I'm finding that this functionality is much easier to implement
      in Common Lisp.
    </p>
    
    <h2>Installing</h2>

    <p>Repo-install is bootstrapped using a tarball that can be found
      <a href="http://www.machineinsight.com/repo-install/repo-install-bootstrap.tgz">
	http://www.machineinsight.com/repo-install/repo-install-bootstrap.tgz</a>.
      The tarball contains the minimum set of packages needed to get
      repo-install working. The bootstrap packages (like all
      repo-install packages) are actually software
      repositories. Patches to these systems (including repo-install)
      can be submitted according to conventions for the given system.</p>

    <p>Untar to a convenient location and add the following to
      your lisp initialization file.</p>

    <p>
      <pre>(load "<i>&lt;location where you untarred&gt;</i>/repo-install/boot.lisp")</pre>
    </p>

    <p>Repo-install takes the philosophy that the correct version
      control system to use is the one the upstream package maintainer
      is using. Therefore, you will
      need <a href="http://git-scm.com/">Git</a>, <a href="http://bazaar-vcs.org/">Bazaar</a>, <a href="http://subversion.tigris.org/">Subversion</a>,
      and <a href="http://darcs.net/">Darcs</a> installed on your
      system. Using <a href="http://www.macports.org/">MacPorts</a> on OSX, do this:

      <pre>sudo port install git-core bzr subversion darcs</pre></p>
    <p>Under debian, do:
      <pre>sudo apt-get install git-core bzr subversion darcs</pre></p>

    <h2>How repo-install handles different upstream repositories</h2>

    <p>Repo-install adopts different strategies for maintaining local
    patches, depending on the upstream repository.</p>

    <p>The best case is if the upstream repository is a DVC. Currently
    repo-install supports darcs and git. (bzr support is planned) In
    these cases, we maintain our local changes in the local repository
    and use the <em>pull</em> command to grab upstream
    patches. Patches can be submitted to the upstream repository using
    appropriate technique ("darcs send" or "git format-patch").</p>

    <p>Upstream tarballs are downloaded and stored in a bzr repository
    named "upstream" in the library's repo-installer directory. An
    "update-repo" operation on these repositories will check for a new
    tarball, and if one exists, update this repository.  Local patches
    are stored in a repository named "local" in the same
    directory. When the "upstream" repository is updated, repo-install
    will pull the changes to the "local" repository in order to
    integrate your patches. Patches can be submitted to the upstream
    provider by diffing the "upstream" and "local" working
    directories.</p>
    
    <p>Finally, non-distributed version control systems simply check
    out the upstream library. Local patches are maintained in your
    local working directory. Patches can be submitted to the upstream
    provider by getting write access to the repository, or by using
    the version control system's "diff" command.</p>
    
    <h2>The Manifest</h2>
    <p>Repo-install gets library download locations from a lisp file
    that we call the manifest. Currently, there is only one manifest
    that ships with repo-install, most-recent-manifest.lisp. This
    manifest can be used to download the most recent publicly
    available library versions.</p>

    <p>A manifest is simply a set of make-instance expressions that
    create CLOS objects. We currently have CLOS objects that represent
    the following upstream repositories:</p>

      <table rules="all" border="1">
	<tr><th>CLOS Class</th><th>Description</th></tr>
	<tr><td>tarball-backed-bzr-repo</td><td>Upstream is a set of tarballs. Local patches are maintained in a bzr repository.</td></tr>
	<tr><td>cliki-repo</td><td>A tarball-backed-bzr-repo who's url is grabbed from cliki.net.</td></tr>
	<tr><td>darcs-repo</td><td>Upstream is a Darcs repository.</td></tr>
	<tr><td>git-repo</td><td>Upstream is a Git repository.</td></tr>
	<tr><td>svn-repo</td><td>Upstream is a SVN repository.</td></tr>
	<tr><td>cvs-repo</td><td>Upstream is a CVS repository.</td></tr>
      </table>

    <p>You can look in most-recent-manifest.lisp for examples of each of these classes.</p>

    <p>Feel free to add any packages that you may need to this file and submit a patch.</p>
      
    
    <h2>Exported Functions</h2>
    <ul>
      <li><b>(ri:install <i>package</i>)</b><p> Install the given package,
	  possibly downloading it and any dependencies found in its asdf
	  system definition. If a particular dependency is not found in
	  the manifest, *current-manifest*, signal an error. In this case,
	  you'll have to add the package to the manifest and try again.</p></li>
      <li><b>(ri:find-repo <i>package</i>)</b><p>
	  Find the repository with the given name.
      </p></li>
      <li><b>(ri:update-repo <i>repo</i>)</b><p> Download any
	  changes from the upstream repository. For distributed
	  version control systems, this is equivalent to a pull. 
	  <p>Non-distributed version control systems perform an update. Repo-install The strategy 
      </p></li>
      <li><b>(ri:update-all-repos)</b><p>
	  Update all repos that have ever been downloaded on this machine.
      </p></li>
      <li><b>(ri:repos-status <i>repo</i>)</b><p> Return a string
	  describing any changes made to the local working directory
	  that are not yet checked in. If repo-install
	  can <em>reliably</em> detect that no changes have been made,
	  return nil.
      </p></li>
      <li><b>(ri:all-repo-status)</b><p> Run repo-status on all
	  locally installed libraries. Print out descriptions of
	  packages that have uncommitted changes.
      </p></li>
      <li><b>(ri:local-repo-changes <i>repo</i>)</b><p> Return a
	  string describing any changes made to the local repository
	  that are not yet checked in to the upstream repository. If
	  repo-install can <em>reliably</em> detect that no changes
	  have been made, return nil.
      </p></li>
      <li><b>(ri:all-local-repo-changes)</b><p> Run local-repo-changes
	  on all locally installed libraries. Print out descriptions
	  of packages that have uncommitted changes.
      </p></li>
    </ul>

    <h2>Patches and Issues</h2>
    <p> Please use the <a href="http://github.com/jpalmucci/repo-install">repo-install github page</a> to submit issues and patches. </p>

    <h2>To Do</h2>
    Ordered by priority.
    <ul>
      <li>Automatically run regression tests on update (for packages that have regression tests).</li>
      <li>implement 'darcs trackdown' across all repository types.</li>
      <li>Code to automatically submit patches.</li>
      <li>Able to specify a tag or a branch on the upstream repository</li>
      <li>Make it easy to publish your local patches to others.</li>
    </ul> 
  </body>
</html>
